---
source: crates/minipg-codegen/tests/codegen_tests.rs
expression: code
---
// Generated parser for Calculator grammar
// DO NOT EDIT - This file is automatically generated

use std::fmt;

#[derive(Debug, Clone, PartialEq)]
pub struct Token {
    pub kind: TokenKind,
    pub text: String,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum TokenKind {
    NUMBER,
    Eof,
}

/// AST node types.
#[derive(Debug, Clone)]
pub enum AstNode {
    Expr(Box<Expr>),
    Term(Box<Term>),
}

/// Listener trait for AST events.
pub trait Listener {
    fn enter_expr(&mut self, _node: &Expr) {}
    fn exit_expr(&mut self, _node: &Expr) {}
    fn enter_term(&mut self, _node: &Term) {}
    fn exit_term(&mut self, _node: &Term) {}
}

/// Lexer for Calculator grammar.
#[derive(Debug)]
pub struct CalculatorLexer {
    input: Vec<char>,
    position: usize,
}

impl CalculatorLexer {
    pub fn new(input: &str) -> Self {
        Self {
            input: input.chars().collect(),
            position: 0,
        }
    }

    pub fn next_token(&mut self) -> Token {
        // TODO: Implement lexer
        unimplemented!()
    }
}

/// Parser for Calculator grammar.
#[derive(Debug)]
pub struct CalculatorParser {
    tokens: Vec<Token>,
    position: usize,
}

impl CalculatorParser {
    pub fn new(tokens: Vec<Token>) -> Self {
        Self { tokens, position: 0 }
    }

    /// Parse expr rule.
    pub fn parse_expr(&mut self) -> Result<AstNode> {
        // TODO: Implement rule parsing
        unimplemented!()
    }

    /// Parse term rule.
    pub fn parse_term(&mut self) -> Result<AstNode> {
        // TODO: Implement rule parsing
        unimplemented!()
    }

}
