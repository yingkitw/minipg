//! Rust code generator.

use crate::visitor_gen::{generate_listener, generate_visitor};
use minipg_ast::{Grammar, Rule};
use minipg_core::{types::CodeGenConfig, CodeGenerator as CodeGeneratorTrait, Result};

/// Rust code generator.
pub struct RustCodeGenerator;

impl RustCodeGenerator {
    pub fn new() -> Self {
        Self
    }

    fn generate_parser_struct(&self, grammar: &Grammar) -> String {
        let mut code = String::new();
        
        code.push_str(&format!("/// Parser for {} grammar.\n", grammar.name));
        code.push_str("#[derive(Debug)]\n");
        code.push_str(&format!("pub struct {}Parser {{\n", grammar.name));
        code.push_str("    tokens: Vec<Token>,\n");
        code.push_str("    position: usize,\n");
        code.push_str("}\n\n");
        
        code
    }

    fn generate_parser_impl(&self, grammar: &Grammar) -> String {
        let mut code = String::new();
        
        code.push_str(&format!("impl {}Parser {{\n", grammar.name));
        code.push_str("    pub fn new(tokens: Vec<Token>) -> Self {\n");
        code.push_str("        Self { tokens, position: 0 }\n");
        code.push_str("    }\n\n");
        
        // Generate methods for each parser rule
        for rule in grammar.parser_rules() {
            code.push_str(&self.generate_rule_method(rule));
        }
        
        code.push_str("}\n\n");
        code
    }

    fn generate_rule_method(&self, rule: &Rule) -> String {
        let mut code = String::new();
        
        code.push_str(&format!("    /// Parse {} rule.\n", rule.name));
        code.push_str(&format!("    pub fn parse_{}(&mut self) -> Result<AstNode> {{\n", rule.name));
        code.push_str("        // TODO: Implement rule parsing\n");
        code.push_str("        unimplemented!()\n");
        code.push_str("    }\n\n");
        
        code
    }

    fn generate_lexer(&self, grammar: &Grammar) -> String {
        let mut code = String::new();
        
        code.push_str(&format!("/// Lexer for {} grammar.\n", grammar.name));
        code.push_str("#[derive(Debug)]\n");
        code.push_str(&format!("pub struct {}Lexer {{\n", grammar.name));
        code.push_str("    input: Vec<char>,\n");
        code.push_str("    position: usize,\n");
        code.push_str("}\n\n");
        
        code.push_str(&format!("impl {}Lexer {{\n", grammar.name));
        code.push_str("    pub fn new(input: &str) -> Self {\n");
        code.push_str("        Self {\n");
        code.push_str("            input: input.chars().collect(),\n");
        code.push_str("            position: 0,\n");
        code.push_str("        }\n");
        code.push_str("    }\n\n");
        
        code.push_str("    pub fn next_token(&mut self) -> Token {\n");
        code.push_str("        // TODO: Implement lexer\n");
        code.push_str("        unimplemented!()\n");
        code.push_str("    }\n");
        code.push_str("}\n\n");
        
        code
    }

    fn generate_ast_types(&self, grammar: &Grammar) -> String {
        let mut code = String::new();
        
        code.push_str("/// AST node types.\n");
        code.push_str("#[derive(Debug, Clone)]\n");
        code.push_str("pub enum AstNode {\n");
        
        for rule in grammar.parser_rules() {
            let variant_name = self.to_pascal_case(&rule.name);
            code.push_str(&format!("    {}(Box<{}>),\n", variant_name, variant_name));
        }
        
        code.push_str("}\n\n");
        code
    }

    fn to_pascal_case(&self, s: &str) -> String {
        s.split('_')
            .map(|word| {
                let mut chars = word.chars();
                match chars.next() {
                    None => String::new(),
                    Some(first) => first.to_uppercase().chain(chars).collect(),
                }
            })
            .collect()
    }
}

impl Default for RustCodeGenerator {
    fn default() -> Self {
        Self::new()
    }
}

impl CodeGeneratorTrait for RustCodeGenerator {
    type Input = Grammar;
    type Config = CodeGenConfig;

    fn generate(&self, input: &Self::Input, config: &Self::Config) -> Result<String> {
        let mut code = String::new();
        
        // Header
        code.push_str(&format!("// Generated parser for {} grammar\n", input.name));
        code.push_str("// DO NOT EDIT - This file is automatically generated\n\n");
        
        // Imports
        code.push_str("use std::fmt;\n\n");
        
        // Token type
        code.push_str("#[derive(Debug, Clone, PartialEq)]\n");
        code.push_str("pub struct Token {\n");
        code.push_str("    pub kind: TokenKind,\n");
        code.push_str("    pub text: String,\n");
        code.push_str("}\n\n");
        
        code.push_str("#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n");
        code.push_str("pub enum TokenKind {\n");
        for rule in input.lexer_rules() {
            if !rule.is_fragment {
                code.push_str(&format!("    {},\n", rule.name));
            }
        }
        code.push_str("    Eof,\n");
        code.push_str("}\n\n");
        
        // Generate AST types
        code.push_str(&self.generate_ast_types(input));
        
        // Generate visitor pattern if requested
        if config.generate_visitor {
            code.push_str(&generate_visitor(input));
        }
        
        // Generate listener pattern if requested
        if config.generate_listener {
            code.push_str(&generate_listener(input));
        }
        
        // Generate lexer
        code.push_str(&self.generate_lexer(input));
        
        // Generate parser
        code.push_str(&self.generate_parser_struct(input));
        code.push_str(&self.generate_parser_impl(input));
        
        Ok(code)
    }

    fn target_language(&self) -> &str {
        "rust"
    }
}
