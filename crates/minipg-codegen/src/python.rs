//! Python code generator.

use minipg_ast::Grammar;
use minipg_core::{types::CodeGenConfig, CodeGenerator as CodeGeneratorTrait, Result};

/// Python code generator.
pub struct PythonCodeGenerator;

impl PythonCodeGenerator {
    pub fn new() -> Self {
        Self
    }
    
    fn generate_lexer(&self, grammar: &Grammar) -> String {
        let mut code = String::new();
        let class_name = format!("{}Lexer", grammar.name);
        
        code.push_str(&format!("class {}:\n", class_name));
        code.push_str("    def __init__(self, input_text):\n");
        code.push_str("        self.input = input_text\n");
        code.push_str("        self.position = 0\n\n");
        
        code.push_str("    def next_token(self):\n");
        code.push_str("        # TODO: Implement lexer\n");
        code.push_str("        pass\n\n");
        
        code
    }
    
    fn generate_parser(&self, grammar: &Grammar) -> String {
        let mut code = String::new();
        let class_name = format!("{}Parser", grammar.name);
        
        code.push_str(&format!("class {}:\n", class_name));
        code.push_str("    def __init__(self, tokens):\n");
        code.push_str("        self.tokens = tokens\n");
        code.push_str("        self.position = 0\n\n");
        
        // Generate parse methods for each rule
        for rule in grammar.parser_rules() {
            code.push_str(&format!("    def parse_{}(self):\n", rule.name));
            code.push_str("        # TODO: Implement rule parsing\n");
            code.push_str("        pass\n\n");
        }
        
        code
    }
    
    fn generate_ast_types(&self, grammar: &Grammar) -> String {
        let mut code = String::new();
        
        code.push_str("from dataclasses import dataclass\n");
        code.push_str("from typing import List, Optional\n\n");
        
        for rule in grammar.parser_rules() {
            let class_name = to_pascal_case(&rule.name);
            code.push_str(&format!("@dataclass\n"));
            code.push_str(&format!("class {}:\n", class_name));
            code.push_str("    pass\n\n");
        }
        
        code
    }
}

impl Default for PythonCodeGenerator {
    fn default() -> Self {
        Self::new()
    }
}

impl CodeGeneratorTrait for PythonCodeGenerator {
    type Input = Grammar;
    type Config = CodeGenConfig;
    
    fn generate(&self, input: &Self::Input, _config: &Self::Config) -> Result<String> {
        let mut code = String::new();
        
        // Header
        code.push_str(&format!("# Generated parser for {} grammar\n", input.name));
        code.push_str("# DO NOT EDIT - This file is automatically generated\n\n");
        
        // Imports
        code.push_str("from enum import Enum\n");
        code.push_str("from typing import List, Optional, Any\n\n");
        
        // Token enum
        code.push_str("class TokenKind(Enum):\n");
        for rule in input.lexer_rules() {
            if !rule.is_fragment {
                code.push_str(&format!("    {} = '{}'\n", rule.name, rule.name));
            }
        }
        code.push_str("    EOF = 'EOF'\n\n");
        
        // AST types
        code.push_str(&self.generate_ast_types(input));
        
        // Lexer
        code.push_str(&self.generate_lexer(input));
        
        // Parser
        code.push_str(&self.generate_parser(input));
        
        Ok(code)
    }
    
    fn target_language(&self) -> &str {
        "python"
    }
}

fn to_pascal_case(s: &str) -> String {
    s.split('_')
        .map(|word| {
            let mut chars = word.chars();
            match chars.next() {
                None => String::new(),
                Some(first) => first.to_uppercase().chain(chars).collect(),
            }
        })
        .collect()
}

#[cfg(test)]
mod tests {
    use super::*;
    use minipg_ast::{Grammar, Rule};
    use minipg_core::types::GrammarType;

    #[test]
    fn test_python_codegen() {
        let mut grammar = Grammar::new("Calculator".to_string(), GrammarType::Parser);
        grammar.add_rule(Rule::parser_rule("expr".to_string()));
        grammar.add_rule(Rule::lexer_rule("NUMBER".to_string()));
        
        let generator = PythonCodeGenerator::new();
        let config = CodeGenConfig::default();
        let code = generator.generate(&grammar, &config).unwrap();
        
        assert!(code.contains("class CalculatorLexer"));
        assert!(code.contains("class CalculatorParser"));
        assert!(code.contains("def parse_expr"));
    }
}
