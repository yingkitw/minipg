//! JavaScript code generator.

use minipg_ast::Grammar;
use minipg_core::{types::CodeGenConfig, CodeGenerator as CodeGeneratorTrait, Result};

/// JavaScript code generator.
pub struct JavaScriptCodeGenerator;

impl JavaScriptCodeGenerator {
    pub fn new() -> Self {
        Self
    }
    
    fn generate_lexer(&self, grammar: &Grammar) -> String {
        let mut code = String::new();
        let class_name = format!("{}Lexer", grammar.name);
        
        code.push_str(&format!("class {} {{\n", class_name));
        code.push_str("  constructor(input) {\n");
        code.push_str("    this.input = input;\n");
        code.push_str("    this.position = 0;\n");
        code.push_str("  }\n\n");
        
        code.push_str("  nextToken() {\n");
        code.push_str("    // TODO: Implement lexer\n");
        code.push_str("    throw new Error('Not implemented');\n");
        code.push_str("  }\n");
        code.push_str("}\n\n");
        
        code
    }
    
    fn generate_parser(&self, grammar: &Grammar) -> String {
        let mut code = String::new();
        let class_name = format!("{}Parser", grammar.name);
        
        code.push_str(&format!("class {} {{\n", class_name));
        code.push_str("  constructor(tokens) {\n");
        code.push_str("    this.tokens = tokens;\n");
        code.push_str("    this.position = 0;\n");
        code.push_str("  }\n\n");
        
        // Generate parse methods for each rule
        for rule in grammar.parser_rules() {
            let method_name = to_camel_case(&rule.name);
            code.push_str(&format!("  parse{}() {{\n", capitalize(&method_name)));
            code.push_str("    // TODO: Implement rule parsing\n");
            code.push_str("    throw new Error('Not implemented');\n");
            code.push_str("  }\n\n");
        }
        
        code.push_str("}\n\n");
        code
    }
    
    fn generate_token_types(&self, grammar: &Grammar) -> String {
        let mut code = String::new();
        
        code.push_str("const TokenKind = {\n");
        for rule in grammar.lexer_rules() {
            if !rule.is_fragment {
                code.push_str(&format!("  {}: '{}',\n", rule.name, rule.name));
            }
        }
        code.push_str("  EOF: 'EOF'\n");
        code.push_str("};\n\n");
        
        code
    }
}

impl Default for JavaScriptCodeGenerator {
    fn default() -> Self {
        Self::new()
    }
}

impl CodeGeneratorTrait for JavaScriptCodeGenerator {
    type Input = Grammar;
    type Config = CodeGenConfig;
    
    fn generate(&self, input: &Self::Input, _config: &Self::Config) -> Result<String> {
        let mut code = String::new();
        
        // Header
        code.push_str(&format!("// Generated parser for {} grammar\n", input.name));
        code.push_str("// DO NOT EDIT - This file is automatically generated\n\n");
        
        // Token types
        code.push_str(&self.generate_token_types(input));
        
        // Lexer
        code.push_str(&self.generate_lexer(input));
        
        // Parser
        code.push_str(&self.generate_parser(input));
        
        // Exports
        code.push_str(&format!("module.exports = {{\n"));
        code.push_str("  TokenKind,\n");
        code.push_str(&format!("  {}Lexer,\n", input.name));
        code.push_str(&format!("  {}Parser\n", input.name));
        code.push_str("};\n");
        
        Ok(code)
    }
    
    fn target_language(&self) -> &str {
        "javascript"
    }
}

fn to_camel_case(s: &str) -> String {
    let parts: Vec<&str> = s.split('_').collect();
    if parts.is_empty() {
        return String::new();
    }
    
    let mut result = parts[0].to_lowercase();
    for part in &parts[1..] {
        result.push_str(&capitalize(part));
    }
    result
}

fn capitalize(s: &str) -> String {
    let mut chars = s.chars();
    match chars.next() {
        None => String::new(),
        Some(first) => first.to_uppercase().chain(chars).collect(),
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use minipg_ast::{Grammar, Rule};
    use minipg_core::types::GrammarType;

    #[test]
    fn test_javascript_codegen() {
        let mut grammar = Grammar::new("Calculator".to_string(), GrammarType::Parser);
        grammar.add_rule(Rule::parser_rule("expr".to_string()));
        grammar.add_rule(Rule::lexer_rule("NUMBER".to_string()));
        
        let generator = JavaScriptCodeGenerator::new();
        let config = CodeGenConfig::default();
        let code = generator.generate(&grammar, &config).unwrap();
        
        assert!(code.contains("class CalculatorLexer"));
        assert!(code.contains("class CalculatorParser"));
        assert!(code.contains("parseExpr"));
        assert!(code.contains("module.exports"));
    }
}
