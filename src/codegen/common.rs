//! Common code generation utilities shared across all code generators.

use crate::ast::{Grammar, Rule};

/// Common patterns and utilities for code generation.

/// Token type information for code generation
pub struct TokenTypeInfo {
    pub name: String,
    pub is_fragment: bool,
}

impl TokenTypeInfo {
    pub fn from_rule(rule: &Rule) -> Self {
        Self {
            name: rule.name.clone(),
            is_fragment: rule.is_fragment,
        }
    }
}

/// Extract token types from grammar (excluding fragments)
pub fn extract_token_types(grammar: &Grammar) -> Vec<String> {
    grammar
        .lexer_rules()
        .filter(|r| !r.is_fragment)
        .map(|r| r.name.clone())
        .collect()
}

/// Extract all lexer rules (including fragments) for reference
pub fn extract_all_lexer_rules(grammar: &Grammar) -> Vec<&Rule> {
    grammar.lexer_rules().collect()
}

/// Extract parser rules
pub fn extract_parser_rules(grammar: &Grammar) -> Vec<&Rule> {
    grammar.parser_rules().collect()
}

/// Get named action code if present
pub fn get_named_action<'a>(grammar: &'a Grammar, action_name: &str) -> Option<&'a String> {
    grammar.named_actions.get(action_name)
}

/// Get lexer-specific named action
pub fn get_lexer_named_action<'a>(grammar: &'a Grammar, action_name: &str) -> Option<&'a String> {
    let key = format!("lexer::{}", action_name);
    grammar.named_actions.get(&key)
}

/// Get parser-specific named action
pub fn get_parser_named_action<'a>(grammar: &'a Grammar, action_name: &str) -> Option<&'a String> {
    let key = format!("parser::{}", action_name);
    grammar.named_actions.get(&key)
}

/// Generate standard header comment
pub fn generate_header_comment(grammar: &Grammar, _language: &str) -> String {
    format!(
        "// Generated parser for {} grammar\n// DO NOT EDIT - This file is automatically generated by minipg\n\n",
        grammar.name
    )
}

/// Generate standard header comment (Python style)
pub fn generate_header_comment_python(grammar: &Grammar) -> String {
    format!(
        "# Generated parser for {} grammar\n# DO NOT EDIT - This file is automatically generated by minipg\n\n",
        grammar.name
    )
}

/// Common token structure fields (for documentation)
pub struct TokenFields {
    pub kind: String,
    pub text: String,
    pub position: String,
    pub line: Option<String>,
    pub column: Option<String>,
    pub length: Option<String>,
}

impl Default for TokenFields {
    fn default() -> Self {
        Self {
            kind: "kind".to_string(),
            text: "text".to_string(),
            position: "position".to_string(),
            line: Some("line".to_string()),
            column: Some("column".to_string()),
            length: Some("length".to_string()),
        }
    }
}

/// Common error structure fields
pub struct ErrorFields {
    pub message: String,
    pub position: String,
    pub expected: Option<String>,
    pub found: Option<String>,
}

impl Default for ErrorFields {
    fn default() -> Self {
        Self {
            message: "message".to_string(),
            position: "position".to_string(),
            expected: Some("expected".to_string()),
            found: Some("found".to_string()),
        }
    }
}

/// Common lexer structure fields
pub struct LexerFields {
    pub input: String,
    pub position: String,
    pub length: Option<String>,
    pub line: Option<String>,
    pub column: Option<String>,
    pub mode: Option<String>,
}

impl Default for LexerFields {
    fn default() -> Self {
        Self {
            input: "input".to_string(),
            position: "position".to_string(),
            length: Some("length".to_string()),
            line: Some("line".to_string()),
            column: Some("column".to_string()),
            mode: Some("mode".to_string()),
        }
    }
}

/// Common parser structure fields
pub struct ParserFields {
    pub tokens: String,
    pub position: String,
}

impl Default for ParserFields {
    fn default() -> Self {
        Self {
            tokens: "tokens".to_string(),
            position: "position".to_string(),
        }
    }
}

/// Helper to generate rule method signature parts
pub struct RuleSignature {
    pub name: String,
    pub arguments: Vec<(String, Option<String>)>, // (name, type)
    pub returns: Vec<(String, Option<String>)>,   // (name, type)
    pub locals: Vec<(String, Option<String>)>,    // (name, type)
}

impl RuleSignature {
    pub fn from_rule(rule: &Rule) -> Self {
        Self {
            name: rule.name.clone(),
            arguments: rule
                .arguments
                .iter()
                .map(|a| (a.name.clone(), a.arg_type.clone()))
                .collect(),
            returns: rule
                .returns
                .iter()
                .map(|r| (r.name.clone(), r.return_type.clone()))
                .collect(),
            locals: rule
                .locals
                .iter()
                .map(|l| (l.name.clone(), l.local_type.clone()))
                .collect(),
        }
    }
}

/// Format identifier according to language conventions
pub fn format_identifier(name: &str, language: &str) -> String {
    match language {
        "rust" => {
            // Rust: snake_case
            name.chars()
                .enumerate()
                .map(|(i, c)| {
                    if i == 0 {
                        c.to_lowercase().to_string()
                    } else if c.is_uppercase() {
                        format!("_{}", c.to_lowercase())
                    } else {
                        c.to_string()
                    }
                })
                .collect()
        }
        "python" => {
            // Python: snake_case
            name.to_lowercase()
        }
        "javascript" | "typescript" => {
            // JavaScript/TypeScript: camelCase
            let mut chars = name.chars();
            match chars.next() {
                None => String::new(),
                Some(first) => first.to_lowercase().collect::<String>() + chars.as_str(),
            }
        }
        "go" => {
            // Go: PascalCase for exported, camelCase for unexported
            name.to_string()
        }
        "java" => {
            // Java: camelCase
            let mut chars = name.chars();
            match chars.next() {
                None => String::new(),
                Some(first) => first.to_lowercase().collect::<String>() + chars.as_str(),
            }
        }
        "c" | "cpp" | "c++" => {
            // C/C++: snake_case
            name.to_lowercase()
        }
        _ => name.to_string(),
    }
}

/// Format type name according to language conventions
pub fn format_type_name(name: &str, language: &str) -> String {
    match language {
        "rust" => {
            // Rust: PascalCase
            let mut chars = name.chars();
            match chars.next() {
                None => String::new(),
                Some(first) => first.to_uppercase().collect::<String>() + chars.as_str(),
            }
        }
        "python" => {
            // Python: PascalCase for classes
            let mut chars = name.chars();
            match chars.next() {
                None => String::new(),
                Some(first) => first.to_uppercase().collect::<String>() + chars.as_str(),
            }
        }
        "javascript" | "typescript" => {
            // JavaScript/TypeScript: PascalCase
            let mut chars = name.chars();
            match chars.next() {
                None => String::new(),
                Some(first) => first.to_uppercase().collect::<String>() + chars.as_str(),
            }
        }
        "go" => {
            // Go: PascalCase
            name.to_string()
        }
        "java" => {
            // Java: PascalCase
            let mut chars = name.chars();
            match chars.next() {
                None => String::new(),
                Some(first) => first.to_uppercase().collect::<String>() + chars.as_str(),
            }
        }
        "c" | "cpp" | "c++" => {
            // C/C++: PascalCase or UPPER_CASE
            name.to_uppercase()
        }
        _ => name.to_string(),
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_extract_token_types() {
        // This would require a full Grammar, so we'll test the helper functions
        assert_eq!(format_identifier("MyVariable", "rust"), "my_variable");
        assert_eq!(format_identifier("MyVariable", "python"), "myvariable");
        assert_eq!(format_identifier("MyVariable", "javascript"), "myVariable");
        assert_eq!(format_identifier("MyVariable", "go"), "MyVariable");
    }
}

